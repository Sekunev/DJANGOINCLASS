terzi kıyafet dikecek;
dockerfile -> terzinin kalıp oluşturmak için aldığı ölçüler
image -> alınan ölçüler ile oluşturulan kalıp
container -> terzinin kalıbı kullanarak her diktiği kıyafet
ölçüler (dockerfile) bir kere alındıktan sonra terzi sadece kalıbı (image) tekrar tekrar kullanarak yeni kıyafetler (container) dikiyor

# boş bir klasör aç ve içine;

# apps.py (python dosyası)
print('hello world')

# dockerfile (docker dosyası)
FROM python:alpine3.17   --> Hangi image'den docker hup dan alıyoruz. Arama çubuguna python yazarak tag'lardan ulaşarak seçim yapıyoruz. (https://hub.docker.com/_/python/tags)
WORKDIR /app --> Çalışma directory oluşturur.
COPY . . -->ilk nokta lokaldeki bütün dosyalar ikinci container'deki kopyalanacak yerler.
CMD python apps.py --> Container oluştuktan sonra apps.py'ın çalıştırılmasını istiyorum.

# image oluşturmak için;
docker build .

# oluşturulan image'ları görmek için
docker images
docker image ls

REPOSITORY                    TAG       IMAGE ID       CREATED         SIZE
<none>                        <none>    6e9bf76e581e   4 minutes ago   52.4MB

# oluşturulan image'ları silmek için
docker image rm xox (id nin ilk 3 karakteri)

# İmage oluşturmanın daha iyi yolu TAG vererek image oluşturmak
docker build -t hello-world:1 .

REPOSITORY                    TAG       IMAGE ID       CREATED         SIZE
hello-world                   1         587303952c5c   4 seconds ago   52.4MB

# image'dan docker container oluşturmak için;
docker run hello-world:1
# çıktısı --> hello world

# çalışan containerları görmek için;
docker ps

# çalışan/çalışmayan containerları görmek için;
docker ps -a

# it (interaktif modda çalıştı, ve bana terminal açtı)
# default bash, çıkmak için exit
docker run -it hello-world:1 sh
açılan terminalde ls , python apps.py gibi komutları çalıştırabilirim.

#  image'ları silmek için ilave; (remove image with force)
# bir containere bağlı ise -f kullanmak gerekir.
docker rmi -f hello-world:1

Pull edilen image silmek için.
docker rmi -f xxx (image id'nin 3 harfi)

# çalışmayan bütün container'ları silmek için
docker container prune
# peşiden docker ps -a çalışırsa;
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
(boş gelir.)

# dockerhub'da repository oluşturmak için,
https://hub.docker.com/
Repositories --> Create Repository
hello-world (repo ismi)


# image repo'ya push yapmak için;
# önceden image yoksa (docker build -t hello-world:1 .)

# docker push dockerusername/repositoryname
docker push sekune/hello-world

# An image does not exist locally with the tag: sekune/hello-world , hatası varsa

# var olan iamage tag değiştirmek için;
docker tag hello-world:1 sekune/hello-world:v1

REPOSITORY                    TAG       IMAGE ID       CREATED          SIZE  
hello-world                   1         a4094132c6f1   19 minutes ago   52.4MB sekune/hello-world         v1        a4094132c6f1   19 minutes ago   52.4MB

# tekrar push ediyoruz,
docker push sekune/hello-world:v1

# pull etmek için
docker pull eneagega/hello-world:v1

# var olan image'lar bakıyorum eneagega gelmiş mi?
docker images
REPOSITORY                    TAG       IMAGE ID       CREATED          SIZE sekune/hello-world         v1        a4094132c6f1   25 minutes ago   52.4MB
hello-world                   1         a4094132c6f1   25 minutes ago   52.4MB
eneagega/hello-world          v1        405a1d8e0109   48 minutes ago   52.4MB

# çalıştırmak için,
docker run eneagega/hello-world:v1
docker run 405(image ID ilk 3 rakamı)

Yukarıda Frontend ve backend uygulamalarını ayrı ayrı image ve container oluşturduk. Bunları tek bir çatı altında birleştirebiliriz. Bunun Yolu.
1- docker-compose.yml gibi her iki uygulama ile aynı dizinde bir dosya oluşturuyoruz.

2- Aşağıdaki gibi içeriğini dolduruyoruz.
services:
  frontend:
    container_name: frontend
    image: docker-compose-fronted
    build: ./frontend
    ports:
      - 3000:3000
      - 80:3000
    restart: on-failure
    depends_on:
      - backend # first run backend. Önce backend'i ayağa kaldır.

  backend:
    # container_name: backend # optional (default:key)
    image: docker-compose-backend # build, if no image/ imageye vereceği isim
    build: ./backend # Which folder (project folder) (must be dockerfile in the folder) Hangi klasör (proje klasörü) (klasörde dockerfile olmalıdır) yol yazıyoruz.
    ports: # external:internal ports
      - 8000:8000
    restart: on-failure # when restart
    volumes: # external:internal volumes
      - ./backend/db.sqlite3:/backend/db.sqlite3 # ilki yerel ikinci container

3- # Yukarıdaki dosyayı oluşturduktan sonra terminalde her iki uygulamayıda kapsayan dosya yolu içerisinde aşağıdaki komutları çalıştır.
# $ docker compose up # compose çalıştır.
# $ docker compose up -d --build # compose daemon aç ve tekrar build et. Yerelde yapılan değişikliklerin container'ede yansımasını istiyorsak bu komut kullanılmalı.
# $ docker compose down # compose kapat.

4- Backendde tabloları oluşturmak için aşağıdaki komut.
docker compose exec backend python manage.py migrate
Container oluştuktan sonra Container içerisinde Backend komutlarını çalıştırabiliriz. Bunu yapmak için önce 
docker compose exec --> den sonra (workdir:backend) sonra backend komutu.
örneğin backend app'inde superUser oluşturmak için.
docker compose exec backend python manage.py createsuperuser

Postgres db oluşturmak için.
1- settings.py'da sqlite3'ü pasif hale getir ve aşağıdaki komutu yapıştır.
DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": config("SQL_DATABASE"),
        "USER": config("SQL_USER"),
        "PASSWORD": config("SQL_PASSWORD"),
        "HOST": config("SQL_HOST", "localhost"),
        "PORT": config("SQL_PORT"),
        "ATOMIC_REQUESTS": True,
    }
} 
2- .env dosyasına eklemeleri yap

SQL_DATABASE=docker-django
SQL_USER=sekune
SQL_PASSWORD=123456Aa.
SQL_HOST=db
SQL_PORT=5432

3- docker-compose.yml'de yeni bir app oluştur.

services:
  backend:
    # container_name: backend # optional (default:key)
    image: docker-compose-backend # build, if no image
    build: ./backend # Which folder (project folder) (must be dockerfile in the folder)
    ports: # external:internal ports
      - 8000:8000
    restart: on-failure # when restart
    env_file:
      - ./backend/.env
    depends_on:
      - db
    volumes: # external:internal volumes
      - ./backend:/backend

  db: # ismini kendin belirle.
    image: postgres:13-alpine  # dockerhub'dan hazır alıyoruz.
    volumes:
      - pg_data:/var/lib/postgresql/data/
    environment: # .env'deki değişkenlerden farklı ama valueleri aynı.
      - POSTGRES_USER=sekune
      - POSTGRES_PASSWORD=123456Aa.
      - POSTGRES_DB=docker-django

  frontend:
    # container_name: frontend
    image: docker-compose-frontend
    build: ./frontend
    ports:
      - 3000:3000
    restart: on-failure
    depends_on:
      - backend # first run backend.
    volumes:
      - ./frontend:/frontend

volumes:
  pg_data:

4- requirements.txt'ye aşağıdaki paketi ekle. 
psycopg2-binary>=2.8

5- requirements.txt'de aşağııdakiler kaldı. gereksizler hata oluşmasına sebep olabilir.
django-cors-headers==3.13.0
djangorestframework==3.14.0
python-decouple==3.6
psycopg2-binary>=2.8